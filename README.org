
* Introduction

The =ox_task= framework provides a way to run commands in a way
similar to AWS Lambda but with much simpler configuration and without
AWS. By using GitHub actions to invoke =ox_task=, you can easily
trigger tasks to run on a schedule or in response to other
events. Even better, you can easily fork someone else's GitHub repo
which has a workflow based on =ox_task= and get the workflow working
for you as well.

** Benefits

Some benefits of using =ox_task= with GitHub actions include:

  1. Programmers can easily create simple scripts or complex commands which run in the cloud (including a generous amount of free computing minutes from GitHub).
  2. Non-programmers can easily fork examples and customize them or ask LLMs like ChatGPT, Gemini, or Claude to generate simple python scripts.
     - The benefit of =ox_task= with GitHub actions is that you can easily get your desired scripts running the cloud.
  3. Configuration, secret management, logs, etc., are generally easier than other cloud platforms

* Examples

The following provide some examples of how you can use =ox_task= by
forking a GitHub repo and setting a few parameters to get your own
custom cloud jobs:

- https://github.com/emin63/simple_example_tasks
  - Simple example for weather and news alerts.

* Frequently Asked Questions

** Why use ox_task instead of python with raw GitHub Actions?

Anything you can do with =ox_task=, you can do with python and raw
GitHub Actions, so why use =ox_task= at all? The answer is that
=ox_task= simplifies the process by eliminating some of the
boilerplate, providing built-in notification systems, and utilities
like environment isolation and retrieving remote scripts.

In addition, =ox_task= tries to collect the key functionality required
(e.g., environment setup and notifications) in a way where you can
just say what you need in the =tasks.json= file. This simplifies setup
and also keeps the GitHub actions workflow file simpler.

* Specification

To launch tasks, you create a JSON file defining your "Task Plan" as
described below. You then execute your task plan via something like:

#+BEGIN_SRC sh
ox_task run /path/to/tasks.json
#+END_SRC

By setting up GitHub actions to schedule a workflow to run the above,
you can easily get scheduled cloud jobs (e.g., see
[[https://github.com/emin63/simple_example_tasks][emin63/simple_example_tasks]]).


** Task Plan

A task plan consists of one or more task files. A task file can either
be a JSON file or a python module. In either case, there should be the
following top-level dictionaries:

- envs: A dictionary of TaskEnv objects (see below).
- notes: A dictionary of TaskNote objects (see below).
- jobs: A dictionary of TaskJob objects (see below).

*** TaskEnv

A TaskEnv represents the environment to run a task. It should be a
dictionary with the following elements:

- runtime: Optional string indicating python runtime environment (e.g,
  python3.11).
- requirements: Optional list of strings indicating project
  dependencies in the same format of a python requirements file. The
  requirements are installed only once even if the TaskEnv is used by
  multiple TaskJobs.
- path: Optional path (relative to the main task runner root).
- variables: Dictionary of environment variable names and values to
  define.
  - Environment variable substitution is performed (e.g., the values
    can contain things like =$USER=, =$HOSTTYPE=, and so on).
  - If a value in the =variables= dictionary starts and ends with the
    backtick character (=`=), then we invoke the shell to evaluate it.
    Use this sparingly since it can introduce security issues (e.g.,
    if you have dynamic shell commands where an attacker could
    influence the arguments). Both backtick and substitution happen
    each time a TaskJob uses the environment (e.g., if you do
    something like =`date`= then that will be evaluated each time a
    TaskJob is run using this TaskEnv).

  

*** TaskNote

A TaskNote represents how to log the task results and possibly notify
someone about them. It should be a dictionary with the following
elements:

- class_name: String indicating the Note class to use (e.g.,
  "SimpleFileLog").
- Optional keywords and values passed as a dictionary to the class
  implementation the note.

*** TaskJob

A TaskJob represents how to run the job for a task. It should be a
dictionary with the following elements:

- env: String name of a TaskEnv indicating environment to use in
  running the task.
- note: String name of a TaskNote indicating how to track or notify
  someone about the task results.
- command: A list of strings where the first element is the program to
  run for the command and subsequent strings are
  arguments. Environment variable expansion will be performed.
- timeout: How long to allow the command to run for in seconds.
- shell: Can be true if we should use the shell to evaluate the
  command and false otherwise. The default is false since using the
  shell can cause unexpected behavior (e.g, see
  https://stackoverflow.com/q/3172470/5885546). Usually it is cleaner,
  safer, and easier to define environment variables in the TaskEnv using
  backtick (=`=) to call the shell and then use those environment
  variable values in =command= than to use ~shell=True~ in the TaskJob.
